#!/usr/bin/env python3

from cryptography import x509
from cryptography.utils import CryptographyDeprecationWarning
from cryptography.hazmat.primitives.asymmetric import rsa, ec
from cryptography.hazmat.backends import default_backend
import sys
import re
import json
import warnings

warnings.filterwarnings("ignore", category=CryptographyDeprecationWarning)

def is_pem(datos: bytes) -> bool:
  return b"-----BEGIN CERTIFICATE-----" in datos


def extract_certs_pem(pem_data: bytes):
  pattern = re.compile(
    b'-----BEGIN CERTIFICATE-----.*?-----END CERTIFICATE-----',
    re.DOTALL
  )
  return pattern.findall(pem_data)


def load_certs(cert_path):
  with open(cert_path, 'rb') as f:
    raw_data = f.read()

  if is_pem(raw_data):
    certs_pem = extract_certs_pem(raw_data)
    certs = [x509.load_pem_x509_certificate(cert, default_backend()) for cert in certs_pem]
  else:
    certs = [x509.load_der_x509_certificate(raw_data, default_backend())]
  
  return certs


def get_cert_json(cert):
  cert_obj = {}
  cert_obj["dn"] = list(cert.subject.public_bytes())
  cert_obj["flags"] = 1 if cert.extensions.get_extension_for_class(x509.BasicConstraints).value.ca else 0

  # Get Public Key
  public_key = cert.public_key()

  if isinstance(public_key, rsa.RSAPublicKey):
    # Get N and E as bytes big-endian
    numbers = public_key.public_numbers()
    cert_obj["pkey"] = {}
    cert_obj["pkey"]["type"] = "BR_KEYTYPE_RSA"
    cert_obj["pkey"]["key"] = {}
    cert_obj["pkey"]["key"]["n"] = list(numbers.n.to_bytes((numbers.n.bit_length() + 7) // 8, byteorder='big'))
    cert_obj["pkey"]["key"]["e"] = list(numbers.e.to_bytes((numbers.e.bit_length() + 7) // 8, byteorder='big'))

  elif isinstance(public_key, ec.EllipticCurvePublicKey):
    # Get Q (public point) withot compression
    numbers = public_key.public_numbers()
    x_bytes = numbers.x.to_bytes((numbers.x.bit_length() + 7) // 8, byteorder='big')
    y_bytes = numbers.y.to_bytes((numbers.y.bit_length() + 7) // 8, byteorder='big')
    q_bytes = b'\x04' + x_bytes + y_bytes
    curve_name = public_key.curve.name

    cert_obj["pkey"] = {}
    cert_obj["pkey"]["type"] = "BR_KEYTYPE_EC"
    cert_obj["pkey"]["key"] = {}
    cert_obj["pkey"]["key"]["curve"] = curve_name
    cert_obj["pkey"]["key"]["q"] = list(q_bytes)

  else:
    print("Type of public key not supported")
  return cert_obj

def to_hex(num):
  return str(hex(num))

def to_hex_cpp(nums):
  array_str = ", ".join([to_hex(num) for num in nums])
  return "{ " + array_str + " };"

def json_to_cpp(certs_info):
  cpp_code = "// This file is auto-generated by parse.py\n"
  cpp_code += "// Do not edit it manually.\n\n"
  cpp_code += "#ifndef POCKET_HTTP_BEARSSL_RAW_CERTS_HPP\n"
  cpp_code += "#define POCKET_HTTP_BEARSSL_RAW_CERTS_HPP\n\n"
  cpp_code += "#include <bearssl.h>\n"
  cpp_code += "#define TAs_NUM " + str(len(certs_info)) + "\n"
  cpp_code += """
#ifdef __cplusplus
extern "C" {
#endif

br_x509_pkey create_rsa_key(br_rsa_public_key rsa) {
  br_x509_pkey TA_pkey;
  TA_pkey.key_type = BR_KEYTYPE_RSA;
  TA_pkey.key.rsa = rsa;
  return TA_pkey;
}

br_x509_pkey create_ec_key(br_ec_public_key ec) {
  br_x509_pkey TA_pkey;
  TA_pkey.key_type = BR_KEYTYPE_EC;
  TA_pkey.key.ec = ec;
  return TA_pkey;
}\n
"""

  trust_acnhor = "\n\nstatic const br_x509_trust_anchor TAs[" + str(len(certs_info)) + "] = { "
  trsuct_values = ["TA" + str(i) for i in range(len(certs_info))]
  trust_acnhor += ", ".join(trsuct_values) + " };"

  cpp_end = "\n\n#ifdef __cplusplus\n}\n#endif\n\n"
  cpp_end += "#endif // POCKET_HTTP_BEARSSL_RAW_CERTS_HPP\n"

  for i, cert in enumerate(certs_info):
    idx = str(i)
    data = "\n"
    data += "static const unsigned char TA" + idx + "_DN[] = " + to_hex_cpp(cert["dn"]) + "\n"

    if (cert["pkey"]["type"] == "BR_KEYTYPE_RSA"):
      data += "static const unsigned char TA" + idx + "_RSA_N[] = " + to_hex_cpp(cert["pkey"]["key"]["n"]) + "\n"
      data += "static const unsigned char TA" + idx + "_RSA_E[] = " + to_hex_cpp(cert["pkey"]["key"]["e"]) + "\n"
      data += "static const br_x509_pkey TA" + idx + "_pkey = create_rsa_key({ (unsigned char *)TA" + idx + "_RSA_N, sizeof TA" + idx + "_RSA_N, (unsigned char *)TA" + idx + "_RSA_E, sizeof TA" + idx + "_RSA_E });\n"
    else:
      data += "static const unsigned char TA" + idx + "_EC_Q[] = " + to_hex_cpp(cert["pkey"]["key"]["q"]) + "\n"
      data += "static const br_x509_pkey TA" + idx + "_pkey = create_ec_key({ BR_EC_" + cert["pkey"]["key"]["curve"] + ", (unsigned char *)TA" + idx + "_EC_Q, sizeof TA" + idx + "_EC_Q });\n"
    
    data += "static const br_x509_trust_anchor TA" + idx + " = { { (unsigned char *)TA" + idx + "_DN, sizeof TA" + idx + "_DN }, " + to_hex(cert["flags"]) +  ", TA" + idx + "_pkey };\n"
    cpp_code += data
  return cpp_code + trust_acnhor + cpp_end


if __name__ == "__main__":
  if len(sys.argv) < 2:
    print("USAGE: python parse.py <cert.der|cert.pem|cert.crt>")
  else:
    is_json_mode = "--json" in sys.argv

    certs = load_certs(sys.argv[1])
    print(f"Found {len(certs)} certificate(s).")
    certs_info = [get_cert_json(cert) for cert in certs]
    
    if is_json_mode:
      with open("certs_info.json", "w") as f:
        json.dump(certs_info, f)
        print("JSON created: certs_info.json")
    else:
      cpp_code = json_to_cpp(certs_info)
      with open("certs.hpp", "w") as f:
        f.write(cpp_code)
        print("C++ code created: certs.hpp")